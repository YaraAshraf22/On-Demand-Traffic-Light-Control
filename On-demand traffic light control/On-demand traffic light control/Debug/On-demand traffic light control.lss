
On-demand traffic light control.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000009f2  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  00000a66  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000002  00800060  00800060  00000a66  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000a66  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000a98  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000198  00000000  00000000  00000ad4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000012c3  00000000  00000000  00000c6c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000008c2  00000000  00000000  00001f2f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000da5  00000000  00000000  000027f1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000002c4  00000000  00000000  00003598  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000556  00000000  00000000  0000385c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000011c5  00000000  00000000  00003db2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000128  00000000  00000000  00004f77  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 fc 00 	jmp	0x1f8	; 0x1f8 <__vector_1>
   8:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  10:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  14:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  18:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  1c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  20:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  24:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  28:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  2c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  30:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  34:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  38:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  3c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  40:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  44:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  48:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  4c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  50:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_clear_bss>:
  60:	20 e0       	ldi	r18, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	01 c0       	rjmp	.+2      	; 0x6a <.do_clear_bss_start>

00000068 <.do_clear_bss_loop>:
  68:	1d 92       	st	X+, r1

0000006a <.do_clear_bss_start>:
  6a:	a2 36       	cpi	r26, 0x62	; 98
  6c:	b2 07       	cpc	r27, r18
  6e:	e1 f7       	brne	.-8      	; 0x68 <.do_clear_bss_loop>
  70:	0e 94 0b 02 	call	0x416	; 0x416 <main>
  74:	0c 94 f7 04 	jmp	0x9ee	; 0x9ee <_exit>

00000078 <__bad_interrupt>:
  78:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000007c <APP_INIT>:
}Normal_State;


void APP_INIT	(void)
{
	LED_INIT_ALL();
  7c:	0e 94 d6 01 	call	0x3ac	; 0x3ac <LED_INIT_ALL>
	TIMER_0_INIT();
  80:	0e 94 6d 04 	call	0x8da	; 0x8da <TIMER_0_INIT>
	TIMER_2_INIT();
  84:	0e 94 b2 04 	call	0x964	; 0x964 <TIMER_2_INIT>
	
	PUSH_BUTTON_INIT (PB_INT0);
  88:	80 e0       	ldi	r24, 0x00	; 0
  8a:	0e 94 fc 01 	call	0x3f8	; 0x3f8 <PUSH_BUTTON_INIT>
	EXT_INT_0_INIT_RISING_EDGE();
  8e:	0e 94 66 04 	call	0x8cc	; 0x8cc <EXT_INT_0_INIT_RISING_EDGE>
	
	LED_OFF_ALL();
  92:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <LED_OFF_ALL>
	
	EXT_INT_0_ENABLE;
  96:	8b b7       	in	r24, 0x3b	; 59
  98:	80 64       	ori	r24, 0x40	; 64
  9a:	8b bf       	out	0x3b, r24	; 59
	GLOBAL_INTERRUPT_ENABLE;
  9c:	8f b7       	in	r24, 0x3f	; 63
  9e:	80 68       	ori	r24, 0x80	; 128
  a0:	8f bf       	out	0x3f, r24	; 63
	
	LED_ON(PED_RED_LED);
  a2:	83 e0       	ldi	r24, 0x03	; 3
  a4:	0e 94 58 01 	call	0x2b0	; 0x2b0 <LED_ON>
  a8:	08 95       	ret

000000aa <NORMAL_MODE>:
	GLOBAL_INTERRUPT_ENABLE;
}


void NORMAL_MODE (void)
{
  aa:	cf 93       	push	r28
	Traffic_Flag = 0;
  ac:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
	
	Normal_State=YELLOW_OR_GREEN;
  b0:	81 e0       	ldi	r24, 0x01	; 1
  b2:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <Normal_State>
	//Green on for 5s
	LED_ON(CAR_GREEN_LED);
  b6:	82 e0       	ldi	r24, 0x02	; 2
  b8:	0e 94 58 01 	call	0x2b0	; 0x2b0 <LED_ON>
	TIMER_0_5s_DELAY();
  bc:	0e 94 88 04 	call	0x910	; 0x910 <TIMER_0_5s_DELAY>
	LED_OFF(CAR_GREEN_LED);
  c0:	82 e0       	ldi	r24, 0x02	; 2
  c2:	0e 94 84 01 	call	0x308	; 0x308 <LED_OFF>
	
	//Yellow blink for 5s
	LED_ON(CAR_YELLOW_LED);
  c6:	81 e0       	ldi	r24, 0x01	; 1
  c8:	0e 94 58 01 	call	0x2b0	; 0x2b0 <LED_ON>
	uint8_t i=0;
  cc:	c0 e0       	ldi	r28, 0x00	; 0
	while(i<5)
  ce:	0d c0       	rjmp	.+26     	; 0xea <NORMAL_MODE+0x40>
	{
		if(Traffic_Flag==1)
  d0:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
  d4:	81 30       	cpi	r24, 0x01	; 1
  d6:	19 f4       	brne	.+6      	; 0xde <NORMAL_MODE+0x34>
		{
			LED_OFF(CAR_YELLOW_LED);
  d8:	0e 94 84 01 	call	0x308	; 0x308 <LED_OFF>
			goto END;
  dc:	28 c0       	rjmp	.+80     	; 0x12e <NORMAL_MODE+0x84>
		}
		TIMER_0_1s_DELAY();
  de:	0e 94 9d 04 	call	0x93a	; 0x93a <TIMER_0_1s_DELAY>
		LED_TOGGLE(CAR_YELLOW_LED);
  e2:	81 e0       	ldi	r24, 0x01	; 1
  e4:	0e 94 b0 01 	call	0x360	; 0x360 <LED_TOGGLE>
		i++;
  e8:	cf 5f       	subi	r28, 0xFF	; 255
	LED_OFF(CAR_GREEN_LED);
	
	//Yellow blink for 5s
	LED_ON(CAR_YELLOW_LED);
	uint8_t i=0;
	while(i<5)
  ea:	c5 30       	cpi	r28, 0x05	; 5
  ec:	88 f3       	brcs	.-30     	; 0xd0 <NORMAL_MODE+0x26>
		LED_TOGGLE(CAR_YELLOW_LED);
		i++;
	}
	
	//Red on for 5s
	Normal_State=RED;
  ee:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <Normal_State>
	LED_ON(CAR_RED_LED);
  f2:	80 e0       	ldi	r24, 0x00	; 0
  f4:	0e 94 58 01 	call	0x2b0	; 0x2b0 <LED_ON>
	TIMER_0_5s_DELAY();
  f8:	0e 94 88 04 	call	0x910	; 0x910 <TIMER_0_5s_DELAY>
	LED_OFF(CAR_RED_LED);
  fc:	80 e0       	ldi	r24, 0x00	; 0
  fe:	0e 94 84 01 	call	0x308	; 0x308 <LED_OFF>
	
	Normal_State=YELLOW_OR_GREEN;
 102:	81 e0       	ldi	r24, 0x01	; 1
 104:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <Normal_State>
	//Yellow blink for 5s
	LED_ON(CAR_YELLOW_LED);
 108:	0e 94 58 01 	call	0x2b0	; 0x2b0 <LED_ON>
	
	i=0;
 10c:	c0 e0       	ldi	r28, 0x00	; 0
	while(i<5)
 10e:	0d c0       	rjmp	.+26     	; 0x12a <NORMAL_MODE+0x80>
	{
		if(Traffic_Flag==1)
 110:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 114:	81 30       	cpi	r24, 0x01	; 1
 116:	19 f4       	brne	.+6      	; 0x11e <NORMAL_MODE+0x74>
		{
			LED_OFF(CAR_YELLOW_LED);
 118:	0e 94 84 01 	call	0x308	; 0x308 <LED_OFF>
			goto END;
 11c:	08 c0       	rjmp	.+16     	; 0x12e <NORMAL_MODE+0x84>
		}
		TIMER_0_1s_DELAY();
 11e:	0e 94 9d 04 	call	0x93a	; 0x93a <TIMER_0_1s_DELAY>
		LED_TOGGLE(CAR_YELLOW_LED);
 122:	81 e0       	ldi	r24, 0x01	; 1
 124:	0e 94 b0 01 	call	0x360	; 0x360 <LED_TOGGLE>
		i++;
 128:	cf 5f       	subi	r28, 0xFF	; 255
	Normal_State=YELLOW_OR_GREEN;
	//Yellow blink for 5s
	LED_ON(CAR_YELLOW_LED);
	
	i=0;
	while(i<5)
 12a:	c5 30       	cpi	r28, 0x05	; 5
 12c:	88 f3       	brcs	.-30     	; 0x110 <NORMAL_MODE+0x66>
		i++;
		
	}
	
	END:
	Traffic_Flag = 0;
 12e:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
}
 132:	cf 91       	pop	r28
 134:	08 95       	ret

00000136 <APP_START>:

void APP_START	(void)
{	
	while (1)
	{	
		NORMAL_MODE ();
 136:	0e 94 55 00 	call	0xaa	; 0xaa <NORMAL_MODE>
 13a:	fd cf       	rjmp	.-6      	; 0x136 <APP_START>

0000013c <PEDESTRIAN_MODE>:
	
	END:
	Traffic_Flag = 0;
}
void PEDESTRIAN_MODE (void)
{
 13c:	cf 93       	push	r28
		Traffic_Flag = 1;
 13e:	81 e0       	ldi	r24, 0x01	; 1
 140:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>

		
		switch(Normal_State)
 144:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <Normal_State>
 148:	88 23       	and	r24, r24
 14a:	19 f0       	breq	.+6      	; 0x152 <PEDESTRIAN_MODE+0x16>
 14c:	81 30       	cpi	r24, 0x01	; 1
 14e:	69 f0       	breq	.+26     	; 0x16a <PEDESTRIAN_MODE+0x2e>
 150:	32 c0       	rjmp	.+100    	; 0x1b6 <PEDESTRIAN_MODE+0x7a>
		{
			case (RED):
			{	//Pedestrian can cross
				LED_ON(CAR_RED_LED);
 152:	80 e0       	ldi	r24, 0x00	; 0
 154:	0e 94 58 01 	call	0x2b0	; 0x2b0 <LED_ON>
				
				LED_OFF(PED_RED_LED);
 158:	83 e0       	ldi	r24, 0x03	; 3
 15a:	0e 94 84 01 	call	0x308	; 0x308 <LED_OFF>
				LED_ON(PED_GREEN_LED);
 15e:	85 e0       	ldi	r24, 0x05	; 5
 160:	0e 94 58 01 	call	0x2b0	; 0x2b0 <LED_ON>
				TIMER_2_5s_DELAY();
 164:	0e 94 cd 04 	call	0x99a	; 0x99a <TIMER_2_5s_DELAY>

				break;
 168:	26 c0       	rjmp	.+76     	; 0x1b6 <PEDESTRIAN_MODE+0x7a>
			}
			case (YELLOW_OR_GREEN):
			{
				//Ped Red 5s
				LED_ON(PED_RED_LED);
 16a:	83 e0       	ldi	r24, 0x03	; 3
 16c:	0e 94 58 01 	call	0x2b0	; 0x2b0 <LED_ON>
				TIMER_2_5s_DELAY();
 170:	0e 94 cd 04 	call	0x99a	; 0x99a <TIMER_2_5s_DELAY>
				LED_OFF(PED_RED_LED);
 174:	83 e0       	ldi	r24, 0x03	; 3
 176:	0e 94 84 01 	call	0x308	; 0x308 <LED_OFF>
				
				LED_OFF(CAR_GREEN_LED);
 17a:	82 e0       	ldi	r24, 0x02	; 2
 17c:	0e 94 84 01 	call	0x308	; 0x308 <LED_OFF>
				
				//Both yellow leds blink for 5s
				LED_ON(CAR_YELLOW_LED);
 180:	81 e0       	ldi	r24, 0x01	; 1
 182:	0e 94 58 01 	call	0x2b0	; 0x2b0 <LED_ON>
				LED_ON(PED_YELLOW_LED);
 186:	84 e0       	ldi	r24, 0x04	; 4
 188:	0e 94 58 01 	call	0x2b0	; 0x2b0 <LED_ON>
				uint8_t i=0;
 18c:	c0 e0       	ldi	r28, 0x00	; 0
				while(i<5)
 18e:	09 c0       	rjmp	.+18     	; 0x1a2 <PEDESTRIAN_MODE+0x66>
				{
					TIMER_2_1s_DELAY();
 190:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <TIMER_2_1s_DELAY>
					LED_TOGGLE(CAR_YELLOW_LED);
 194:	81 e0       	ldi	r24, 0x01	; 1
 196:	0e 94 b0 01 	call	0x360	; 0x360 <LED_TOGGLE>
					LED_TOGGLE(PED_YELLOW_LED);
 19a:	84 e0       	ldi	r24, 0x04	; 4
 19c:	0e 94 b0 01 	call	0x360	; 0x360 <LED_TOGGLE>
					i++;
 1a0:	cf 5f       	subi	r28, 0xFF	; 255
				
				//Both yellow leds blink for 5s
				LED_ON(CAR_YELLOW_LED);
				LED_ON(PED_YELLOW_LED);
				uint8_t i=0;
				while(i<5)
 1a2:	c5 30       	cpi	r28, 0x05	; 5
 1a4:	a8 f3       	brcs	.-22     	; 0x190 <PEDESTRIAN_MODE+0x54>
					LED_TOGGLE(CAR_YELLOW_LED);
					LED_TOGGLE(PED_YELLOW_LED);
					i++;
				}
				
				LED_ON(CAR_RED_LED);
 1a6:	80 e0       	ldi	r24, 0x00	; 0
 1a8:	0e 94 58 01 	call	0x2b0	; 0x2b0 <LED_ON>
				LED_ON(PED_GREEN_LED);
 1ac:	85 e0       	ldi	r24, 0x05	; 5
 1ae:	0e 94 58 01 	call	0x2b0	; 0x2b0 <LED_ON>
				TIMER_2_5s_DELAY();
 1b2:	0e 94 cd 04 	call	0x99a	; 0x99a <TIMER_2_5s_DELAY>
			}
		}

		//After normal to pedestrian state transition

		LED_OFF(CAR_RED_LED);
 1b6:	80 e0       	ldi	r24, 0x00	; 0
 1b8:	0e 94 84 01 	call	0x308	; 0x308 <LED_OFF>
		LED_ON(CAR_YELLOW_LED);
 1bc:	81 e0       	ldi	r24, 0x01	; 1
 1be:	0e 94 58 01 	call	0x2b0	; 0x2b0 <LED_ON>
		LED_ON(PED_YELLOW_LED);
 1c2:	84 e0       	ldi	r24, 0x04	; 4
 1c4:	0e 94 58 01 	call	0x2b0	; 0x2b0 <LED_ON>
		uint8_t i=0;
 1c8:	c0 e0       	ldi	r28, 0x00	; 0
		while(i<5)
 1ca:	09 c0       	rjmp	.+18     	; 0x1de <PEDESTRIAN_MODE+0xa2>
		{
			TIMER_2_1s_DELAY();
 1cc:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <TIMER_2_1s_DELAY>
			LED_TOGGLE(CAR_YELLOW_LED);
 1d0:	81 e0       	ldi	r24, 0x01	; 1
 1d2:	0e 94 b0 01 	call	0x360	; 0x360 <LED_TOGGLE>
			LED_TOGGLE(PED_YELLOW_LED);
 1d6:	84 e0       	ldi	r24, 0x04	; 4
 1d8:	0e 94 b0 01 	call	0x360	; 0x360 <LED_TOGGLE>
			i++;
 1dc:	cf 5f       	subi	r28, 0xFF	; 255

		LED_OFF(CAR_RED_LED);
		LED_ON(CAR_YELLOW_LED);
		LED_ON(PED_YELLOW_LED);
		uint8_t i=0;
		while(i<5)
 1de:	c5 30       	cpi	r28, 0x05	; 5
 1e0:	a8 f3       	brcs	.-22     	; 0x1cc <PEDESTRIAN_MODE+0x90>
			LED_TOGGLE(CAR_YELLOW_LED);
			LED_TOGGLE(PED_YELLOW_LED);
			i++;
		}
		
		LED_OFF(PED_GREEN_LED);
 1e2:	85 e0       	ldi	r24, 0x05	; 5
 1e4:	0e 94 84 01 	call	0x308	; 0x308 <LED_OFF>
		LED_ON(PED_RED_LED);
 1e8:	83 e0       	ldi	r24, 0x03	; 3
 1ea:	0e 94 58 01 	call	0x2b0	; 0x2b0 <LED_ON>
		LED_ON(CAR_GREEN_LED);
 1ee:	82 e0       	ldi	r24, 0x02	; 2
 1f0:	0e 94 58 01 	call	0x2b0	; 0x2b0 <LED_ON>

 1f4:	cf 91       	pop	r28
 1f6:	08 95       	ret

000001f8 <__vector_1>:
	
	
}

ISR (EXT_INT_0)
{
 1f8:	1f 92       	push	r1
 1fa:	0f 92       	push	r0
 1fc:	0f b6       	in	r0, 0x3f	; 63
 1fe:	0f 92       	push	r0
 200:	11 24       	eor	r1, r1
 202:	2f 93       	push	r18
 204:	3f 93       	push	r19
 206:	4f 93       	push	r20
 208:	5f 93       	push	r21
 20a:	6f 93       	push	r22
 20c:	7f 93       	push	r23
 20e:	8f 93       	push	r24
 210:	9f 93       	push	r25
 212:	af 93       	push	r26
 214:	bf 93       	push	r27
 216:	ef 93       	push	r30
 218:	ff 93       	push	r31
	
	GLOBAL_INTERRUPT_DISABLE;
 21a:	8f b7       	in	r24, 0x3f	; 63
 21c:	8f 77       	andi	r24, 0x7F	; 127
 21e:	8f bf       	out	0x3f, r24	; 63
	EXT_INT_0_DISABLE;
 220:	8b b7       	in	r24, 0x3b	; 59
 222:	8f 7b       	andi	r24, 0xBF	; 191
 224:	8b bf       	out	0x3b, r24	; 59
	
	PEDESTRIAN_MODE ();
 226:	0e 94 9e 00 	call	0x13c	; 0x13c <PEDESTRIAN_MODE>
	
	EXT_INT_0_ENABLE;
 22a:	8b b7       	in	r24, 0x3b	; 59
 22c:	80 64       	ori	r24, 0x40	; 64
 22e:	8b bf       	out	0x3b, r24	; 59
	GLOBAL_INTERRUPT_ENABLE;
 230:	8f b7       	in	r24, 0x3f	; 63
 232:	80 68       	ori	r24, 0x80	; 128
 234:	8f bf       	out	0x3f, r24	; 63
}
 236:	ff 91       	pop	r31
 238:	ef 91       	pop	r30
 23a:	bf 91       	pop	r27
 23c:	af 91       	pop	r26
 23e:	9f 91       	pop	r25
 240:	8f 91       	pop	r24
 242:	7f 91       	pop	r23
 244:	6f 91       	pop	r22
 246:	5f 91       	pop	r21
 248:	4f 91       	pop	r20
 24a:	3f 91       	pop	r19
 24c:	2f 91       	pop	r18
 24e:	0f 90       	pop	r0
 250:	0f be       	out	0x3f, r0	; 63
 252:	0f 90       	pop	r0
 254:	1f 90       	pop	r1
 256:	18 95       	reti

00000258 <LED_INIT>:
#include "LED_CFG.h"


void LED_INIT   (uint8_t led)
{
	switch(led)
 258:	82 30       	cpi	r24, 0x02	; 2
 25a:	b1 f0       	breq	.+44     	; 0x288 <LED_INIT+0x30>
 25c:	28 f4       	brcc	.+10     	; 0x268 <LED_INIT+0x10>
 25e:	88 23       	and	r24, r24
 260:	49 f0       	breq	.+18     	; 0x274 <LED_INIT+0x1c>
 262:	81 30       	cpi	r24, 0x01	; 1
 264:	61 f0       	breq	.+24     	; 0x27e <LED_INIT+0x26>
 266:	08 95       	ret
 268:	84 30       	cpi	r24, 0x04	; 4
 26a:	c1 f0       	breq	.+48     	; 0x29c <LED_INIT+0x44>
 26c:	90 f0       	brcs	.+36     	; 0x292 <LED_INIT+0x3a>
 26e:	85 30       	cpi	r24, 0x05	; 5
 270:	d1 f0       	breq	.+52     	; 0x2a6 <LED_INIT+0x4e>
 272:	08 95       	ret
	{
		case 0:
		PIN_MODE(CAR_RED_LED_PIN,OUTPUT);
 274:	61 e0       	ldi	r22, 0x01	; 1
 276:	88 e2       	ldi	r24, 0x28	; 40
 278:	0e 94 12 02 	call	0x424	; 0x424 <PIN_MODE>
		break;
 27c:	08 95       	ret
		case 1:
		PIN_MODE(CAR_YELLOW_LED_PIN,OUTPUT);
 27e:	61 e0       	ldi	r22, 0x01	; 1
 280:	89 e2       	ldi	r24, 0x29	; 41
 282:	0e 94 12 02 	call	0x424	; 0x424 <PIN_MODE>
		break;
 286:	08 95       	ret
		case 2:
		PIN_MODE(CAR_GREEN_LED_PIN,OUTPUT);
 288:	61 e0       	ldi	r22, 0x01	; 1
 28a:	8a e2       	ldi	r24, 0x2A	; 42
 28c:	0e 94 12 02 	call	0x424	; 0x424 <PIN_MODE>
		break;
 290:	08 95       	ret
		case 3:
		PIN_MODE(PED_RED_LED_PIN,OUTPUT);
 292:	61 e0       	ldi	r22, 0x01	; 1
 294:	8a e0       	ldi	r24, 0x0A	; 10
 296:	0e 94 12 02 	call	0x424	; 0x424 <PIN_MODE>
		break;
 29a:	08 95       	ret
		case 4:
		PIN_MODE(PED_YELLOW_LED_PIN,OUTPUT);
 29c:	61 e0       	ldi	r22, 0x01	; 1
 29e:	8b e0       	ldi	r24, 0x0B	; 11
 2a0:	0e 94 12 02 	call	0x424	; 0x424 <PIN_MODE>
		break;
 2a4:	08 95       	ret
		case 5:
		PIN_MODE(PED_GREEN_LED_PIN,OUTPUT);
 2a6:	61 e0       	ldi	r22, 0x01	; 1
 2a8:	8c e0       	ldi	r24, 0x0C	; 12
 2aa:	0e 94 12 02 	call	0x424	; 0x424 <PIN_MODE>
 2ae:	08 95       	ret

000002b0 <LED_ON>:
		break;
	}
}
void LED_ON     (uint8_t led)
{
	switch(led)
 2b0:	82 30       	cpi	r24, 0x02	; 2
 2b2:	b1 f0       	breq	.+44     	; 0x2e0 <LED_ON+0x30>
 2b4:	28 f4       	brcc	.+10     	; 0x2c0 <LED_ON+0x10>
 2b6:	88 23       	and	r24, r24
 2b8:	49 f0       	breq	.+18     	; 0x2cc <LED_ON+0x1c>
 2ba:	81 30       	cpi	r24, 0x01	; 1
 2bc:	61 f0       	breq	.+24     	; 0x2d6 <LED_ON+0x26>
 2be:	08 95       	ret
 2c0:	84 30       	cpi	r24, 0x04	; 4
 2c2:	c1 f0       	breq	.+48     	; 0x2f4 <LED_ON+0x44>
 2c4:	90 f0       	brcs	.+36     	; 0x2ea <LED_ON+0x3a>
 2c6:	85 30       	cpi	r24, 0x05	; 5
 2c8:	d1 f0       	breq	.+52     	; 0x2fe <LED_ON+0x4e>
 2ca:	08 95       	ret
	{
		case 0:
		PIN_WRITE(CAR_RED_LED_PIN,HIGH);
 2cc:	61 e0       	ldi	r22, 0x01	; 1
 2ce:	88 e2       	ldi	r24, 0x28	; 40
 2d0:	0e 94 01 03 	call	0x602	; 0x602 <PIN_WRITE>
		break;
 2d4:	08 95       	ret
		case 1:
		PIN_WRITE(CAR_YELLOW_LED_PIN,HIGH);
 2d6:	61 e0       	ldi	r22, 0x01	; 1
 2d8:	89 e2       	ldi	r24, 0x29	; 41
 2da:	0e 94 01 03 	call	0x602	; 0x602 <PIN_WRITE>
		break;
 2de:	08 95       	ret
		case 2:
		PIN_WRITE(CAR_GREEN_LED_PIN,HIGH);
 2e0:	61 e0       	ldi	r22, 0x01	; 1
 2e2:	8a e2       	ldi	r24, 0x2A	; 42
 2e4:	0e 94 01 03 	call	0x602	; 0x602 <PIN_WRITE>
		break;
 2e8:	08 95       	ret
		case 3:
		PIN_WRITE(PED_RED_LED_PIN,HIGH);
 2ea:	61 e0       	ldi	r22, 0x01	; 1
 2ec:	8a e0       	ldi	r24, 0x0A	; 10
 2ee:	0e 94 01 03 	call	0x602	; 0x602 <PIN_WRITE>
		break;
 2f2:	08 95       	ret
		case 4:
		PIN_WRITE(PED_YELLOW_LED_PIN,HIGH);
 2f4:	61 e0       	ldi	r22, 0x01	; 1
 2f6:	8b e0       	ldi	r24, 0x0B	; 11
 2f8:	0e 94 01 03 	call	0x602	; 0x602 <PIN_WRITE>
		break;
 2fc:	08 95       	ret
		case 5:
		PIN_WRITE(PED_GREEN_LED_PIN,HIGH);
 2fe:	61 e0       	ldi	r22, 0x01	; 1
 300:	8c e0       	ldi	r24, 0x0C	; 12
 302:	0e 94 01 03 	call	0x602	; 0x602 <PIN_WRITE>
 306:	08 95       	ret

00000308 <LED_OFF>:
		break;
	}
}
void LED_OFF    (uint8_t led)
{
	switch(led)
 308:	82 30       	cpi	r24, 0x02	; 2
 30a:	b1 f0       	breq	.+44     	; 0x338 <LED_OFF+0x30>
 30c:	28 f4       	brcc	.+10     	; 0x318 <LED_OFF+0x10>
 30e:	88 23       	and	r24, r24
 310:	49 f0       	breq	.+18     	; 0x324 <LED_OFF+0x1c>
 312:	81 30       	cpi	r24, 0x01	; 1
 314:	61 f0       	breq	.+24     	; 0x32e <LED_OFF+0x26>
 316:	08 95       	ret
 318:	84 30       	cpi	r24, 0x04	; 4
 31a:	c1 f0       	breq	.+48     	; 0x34c <LED_OFF+0x44>
 31c:	90 f0       	brcs	.+36     	; 0x342 <LED_OFF+0x3a>
 31e:	85 30       	cpi	r24, 0x05	; 5
 320:	d1 f0       	breq	.+52     	; 0x356 <LED_OFF+0x4e>
 322:	08 95       	ret
	{
		case 0:
		PIN_WRITE(CAR_RED_LED_PIN,LOW);
 324:	60 e0       	ldi	r22, 0x00	; 0
 326:	88 e2       	ldi	r24, 0x28	; 40
 328:	0e 94 01 03 	call	0x602	; 0x602 <PIN_WRITE>
		break;
 32c:	08 95       	ret
		case 1:
		PIN_WRITE(CAR_YELLOW_LED_PIN,LOW);
 32e:	60 e0       	ldi	r22, 0x00	; 0
 330:	89 e2       	ldi	r24, 0x29	; 41
 332:	0e 94 01 03 	call	0x602	; 0x602 <PIN_WRITE>
		break;
 336:	08 95       	ret
		case 2:
		PIN_WRITE(CAR_GREEN_LED_PIN,LOW);
 338:	60 e0       	ldi	r22, 0x00	; 0
 33a:	8a e2       	ldi	r24, 0x2A	; 42
 33c:	0e 94 01 03 	call	0x602	; 0x602 <PIN_WRITE>
		break;
 340:	08 95       	ret
		case 3:
		PIN_WRITE(PED_RED_LED_PIN,LOW);
 342:	60 e0       	ldi	r22, 0x00	; 0
 344:	8a e0       	ldi	r24, 0x0A	; 10
 346:	0e 94 01 03 	call	0x602	; 0x602 <PIN_WRITE>
		break;
 34a:	08 95       	ret
		case 4:
		PIN_WRITE(PED_YELLOW_LED_PIN,LOW);
 34c:	60 e0       	ldi	r22, 0x00	; 0
 34e:	8b e0       	ldi	r24, 0x0B	; 11
 350:	0e 94 01 03 	call	0x602	; 0x602 <PIN_WRITE>
		break;
 354:	08 95       	ret
		case 5:
		PIN_WRITE(PED_GREEN_LED_PIN,LOW);
 356:	60 e0       	ldi	r22, 0x00	; 0
 358:	8c e0       	ldi	r24, 0x0C	; 12
 35a:	0e 94 01 03 	call	0x602	; 0x602 <PIN_WRITE>
 35e:	08 95       	ret

00000360 <LED_TOGGLE>:
		break;
	}
}
void LED_TOGGLE (uint8_t led)
{
	switch(led)
 360:	82 30       	cpi	r24, 0x02	; 2
 362:	a1 f0       	breq	.+40     	; 0x38c <LED_TOGGLE+0x2c>
 364:	28 f4       	brcc	.+10     	; 0x370 <LED_TOGGLE+0x10>
 366:	88 23       	and	r24, r24
 368:	49 f0       	breq	.+18     	; 0x37c <LED_TOGGLE+0x1c>
 36a:	81 30       	cpi	r24, 0x01	; 1
 36c:	59 f0       	breq	.+22     	; 0x384 <LED_TOGGLE+0x24>
 36e:	08 95       	ret
 370:	84 30       	cpi	r24, 0x04	; 4
 372:	a1 f0       	breq	.+40     	; 0x39c <LED_TOGGLE+0x3c>
 374:	78 f0       	brcs	.+30     	; 0x394 <LED_TOGGLE+0x34>
 376:	85 30       	cpi	r24, 0x05	; 5
 378:	a9 f0       	breq	.+42     	; 0x3a4 <LED_TOGGLE+0x44>
 37a:	08 95       	ret
	{
		case 0:
		PIN_TOGGLE(CAR_RED_LED_PIN);
 37c:	88 e2       	ldi	r24, 0x28	; 40
 37e:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <PIN_TOGGLE>
		break;
 382:	08 95       	ret
		case 1:
		PIN_TOGGLE(CAR_YELLOW_LED_PIN);
 384:	89 e2       	ldi	r24, 0x29	; 41
 386:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <PIN_TOGGLE>
		break;
 38a:	08 95       	ret
		case 2:
		PIN_TOGGLE(CAR_GREEN_LED_PIN);
 38c:	8a e2       	ldi	r24, 0x2A	; 42
 38e:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <PIN_TOGGLE>
		break;
 392:	08 95       	ret
		case 3:
		PIN_TOGGLE(PED_RED_LED_PIN);
 394:	8a e0       	ldi	r24, 0x0A	; 10
 396:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <PIN_TOGGLE>
		break;
 39a:	08 95       	ret
		case 4:
		PIN_TOGGLE(PED_YELLOW_LED_PIN);
 39c:	8b e0       	ldi	r24, 0x0B	; 11
 39e:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <PIN_TOGGLE>
		break;
 3a2:	08 95       	ret
		case 5:
		PIN_TOGGLE(PED_GREEN_LED_PIN);
 3a4:	8c e0       	ldi	r24, 0x0C	; 12
 3a6:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <PIN_TOGGLE>
 3aa:	08 95       	ret

000003ac <LED_INIT_ALL>:
}


void LED_INIT_ALL (void)
{
		LED_INIT(CAR_RED_LED);
 3ac:	80 e0       	ldi	r24, 0x00	; 0
 3ae:	0e 94 2c 01 	call	0x258	; 0x258 <LED_INIT>
		LED_INIT(CAR_YELLOW_LED);
 3b2:	81 e0       	ldi	r24, 0x01	; 1
 3b4:	0e 94 2c 01 	call	0x258	; 0x258 <LED_INIT>
		LED_INIT(CAR_GREEN_LED);
 3b8:	82 e0       	ldi	r24, 0x02	; 2
 3ba:	0e 94 2c 01 	call	0x258	; 0x258 <LED_INIT>
		
		LED_INIT(PED_RED_LED);
 3be:	83 e0       	ldi	r24, 0x03	; 3
 3c0:	0e 94 2c 01 	call	0x258	; 0x258 <LED_INIT>
		LED_INIT(PED_YELLOW_LED);
 3c4:	84 e0       	ldi	r24, 0x04	; 4
 3c6:	0e 94 2c 01 	call	0x258	; 0x258 <LED_INIT>
		LED_INIT(PED_GREEN_LED);
 3ca:	85 e0       	ldi	r24, 0x05	; 5
 3cc:	0e 94 2c 01 	call	0x258	; 0x258 <LED_INIT>
 3d0:	08 95       	ret

000003d2 <LED_OFF_ALL>:
}

void LED_OFF_ALL(void)
{
	LED_OFF(CAR_RED_LED);
 3d2:	80 e0       	ldi	r24, 0x00	; 0
 3d4:	0e 94 84 01 	call	0x308	; 0x308 <LED_OFF>
	LED_OFF(CAR_YELLOW_LED);
 3d8:	81 e0       	ldi	r24, 0x01	; 1
 3da:	0e 94 84 01 	call	0x308	; 0x308 <LED_OFF>
	LED_OFF(CAR_GREEN_LED);
 3de:	82 e0       	ldi	r24, 0x02	; 2
 3e0:	0e 94 84 01 	call	0x308	; 0x308 <LED_OFF>

	LED_OFF(PED_RED_LED);
 3e4:	83 e0       	ldi	r24, 0x03	; 3
 3e6:	0e 94 84 01 	call	0x308	; 0x308 <LED_OFF>
	LED_OFF(PED_YELLOW_LED);
 3ea:	84 e0       	ldi	r24, 0x04	; 4
 3ec:	0e 94 84 01 	call	0x308	; 0x308 <LED_OFF>
	LED_OFF(PED_GREEN_LED);
 3f0:	85 e0       	ldi	r24, 0x05	; 5
 3f2:	0e 94 84 01 	call	0x308	; 0x308 <LED_OFF>
 3f6:	08 95       	ret

000003f8 <PUSH_BUTTON_INIT>:
#include "../../Utilities/STD_TYPES.h"
#include "../../MCAL/DIO/DIO.h"

void  PUSH_BUTTON_INIT (uint8_t button)
{
	switch(button)
 3f8:	88 23       	and	r24, r24
 3fa:	19 f0       	breq	.+6      	; 0x402 <__EEPROM_REGION_LENGTH__+0x2>
 3fc:	81 30       	cpi	r24, 0x01	; 1
 3fe:	31 f0       	breq	.+12     	; 0x40c <__EEPROM_REGION_LENGTH__+0xc>
 400:	08 95       	ret
	{
		case 0:
		PIN_MODE(BUTTON_PIN_INT0,INPUT);
 402:	60 e0       	ldi	r22, 0x00	; 0
 404:	86 e1       	ldi	r24, 0x16	; 22
 406:	0e 94 12 02 	call	0x424	; 0x424 <PIN_MODE>
		break;
 40a:	08 95       	ret
		case 1:
		PIN_MODE(BUTTON_PIN_INT1,INPUT);
 40c:	60 e0       	ldi	r22, 0x00	; 0
 40e:	87 e1       	ldi	r24, 0x17	; 23
 410:	0e 94 12 02 	call	0x424	; 0x424 <PIN_MODE>
 414:	08 95       	ret

00000416 <main>:
#define F_CPU 1000000UL*/


int main(void)
{
	APP_INIT();
 416:	0e 94 3e 00 	call	0x7c	; 0x7c <APP_INIT>
	APP_START();	
 41a:	0e 94 9b 00 	call	0x136	; 0x136 <APP_START>
}
 41e:	80 e0       	ldi	r24, 0x00	; 0
 420:	90 e0       	ldi	r25, 0x00	; 0
 422:	08 95       	ret

00000424 <PIN_MODE>:
#include "../REGISTERS.h"


void PIN_MODE (uint8_t pin,uint8_t mode)
{
	uint8_t port = pin / 10;
 424:	9d ec       	ldi	r25, 0xCD	; 205
 426:	89 9f       	mul	r24, r25
 428:	91 2d       	mov	r25, r1
 42a:	11 24       	eor	r1, r1
 42c:	96 95       	lsr	r25
 42e:	96 95       	lsr	r25
 430:	96 95       	lsr	r25
	switch(mode)
 432:	66 23       	and	r22, r22
 434:	09 f4       	brne	.+2      	; 0x438 <PIN_MODE+0x14>
 436:	72 c0       	rjmp	.+228    	; 0x51c <PIN_MODE+0xf8>
 438:	61 30       	cpi	r22, 0x01	; 1
 43a:	09 f0       	breq	.+2      	; 0x43e <PIN_MODE+0x1a>
 43c:	e1 c0       	rjmp	.+450    	; 0x600 <PIN_MODE+0x1dc>
	{
		case OUTPUT:
		switch(port)
 43e:	92 30       	cpi	r25, 0x02	; 2
 440:	21 f1       	breq	.+72     	; 0x48a <PIN_MODE+0x66>
 442:	18 f4       	brcc	.+6      	; 0x44a <PIN_MODE+0x26>
 444:	91 30       	cpi	r25, 0x01	; 1
 446:	39 f0       	breq	.+14     	; 0x456 <PIN_MODE+0x32>
 448:	08 95       	ret
 44a:	93 30       	cpi	r25, 0x03	; 3
 44c:	c1 f1       	breq	.+112    	; 0x4be <PIN_MODE+0x9a>
 44e:	94 30       	cpi	r25, 0x04	; 4
 450:	09 f4       	brne	.+2      	; 0x454 <PIN_MODE+0x30>
 452:	4c c0       	rjmp	.+152    	; 0x4ec <PIN_MODE+0xc8>
 454:	08 95       	ret
		{
			case 1:
			pin = pin % 10;
 456:	9d ec       	ldi	r25, 0xCD	; 205
 458:	89 9f       	mul	r24, r25
 45a:	91 2d       	mov	r25, r1
 45c:	11 24       	eor	r1, r1
 45e:	96 95       	lsr	r25
 460:	96 95       	lsr	r25
 462:	96 95       	lsr	r25
 464:	99 0f       	add	r25, r25
 466:	29 2f       	mov	r18, r25
 468:	22 0f       	add	r18, r18
 46a:	22 0f       	add	r18, r18
 46c:	92 0f       	add	r25, r18
 46e:	89 1b       	sub	r24, r25
			SET_BIT(DDRB,pin);
 470:	47 b3       	in	r20, 0x17	; 23
 472:	21 e0       	ldi	r18, 0x01	; 1
 474:	30 e0       	ldi	r19, 0x00	; 0
 476:	b9 01       	movw	r22, r18
 478:	02 c0       	rjmp	.+4      	; 0x47e <PIN_MODE+0x5a>
 47a:	66 0f       	add	r22, r22
 47c:	77 1f       	adc	r23, r23
 47e:	8a 95       	dec	r24
 480:	e2 f7       	brpl	.-8      	; 0x47a <PIN_MODE+0x56>
 482:	cb 01       	movw	r24, r22
 484:	84 2b       	or	r24, r20
 486:	87 bb       	out	0x17, r24	; 23
			break;
 488:	08 95       	ret
			case 2:
			pin = pin % 20;
 48a:	9d ec       	ldi	r25, 0xCD	; 205
 48c:	89 9f       	mul	r24, r25
 48e:	91 2d       	mov	r25, r1
 490:	11 24       	eor	r1, r1
 492:	92 95       	swap	r25
 494:	9f 70       	andi	r25, 0x0F	; 15
 496:	99 0f       	add	r25, r25
 498:	99 0f       	add	r25, r25
 49a:	29 2f       	mov	r18, r25
 49c:	22 0f       	add	r18, r18
 49e:	22 0f       	add	r18, r18
 4a0:	92 0f       	add	r25, r18
 4a2:	89 1b       	sub	r24, r25
			SET_BIT(DDRD,pin);
 4a4:	41 b3       	in	r20, 0x11	; 17
 4a6:	21 e0       	ldi	r18, 0x01	; 1
 4a8:	30 e0       	ldi	r19, 0x00	; 0
 4aa:	b9 01       	movw	r22, r18
 4ac:	02 c0       	rjmp	.+4      	; 0x4b2 <PIN_MODE+0x8e>
 4ae:	66 0f       	add	r22, r22
 4b0:	77 1f       	adc	r23, r23
 4b2:	8a 95       	dec	r24
 4b4:	e2 f7       	brpl	.-8      	; 0x4ae <PIN_MODE+0x8a>
 4b6:	cb 01       	movw	r24, r22
 4b8:	84 2b       	or	r24, r20
 4ba:	81 bb       	out	0x11, r24	; 17
			break;
 4bc:	08 95       	ret
			case 3:
			pin = pin % 30;
 4be:	99 e8       	ldi	r25, 0x89	; 137
 4c0:	89 9f       	mul	r24, r25
 4c2:	91 2d       	mov	r25, r1
 4c4:	11 24       	eor	r1, r1
 4c6:	92 95       	swap	r25
 4c8:	9f 70       	andi	r25, 0x0F	; 15
 4ca:	7e e1       	ldi	r23, 0x1E	; 30
 4cc:	97 9f       	mul	r25, r23
 4ce:	80 19       	sub	r24, r0
 4d0:	11 24       	eor	r1, r1
			SET_BIT(DDRC,pin);
 4d2:	44 b3       	in	r20, 0x14	; 20
 4d4:	21 e0       	ldi	r18, 0x01	; 1
 4d6:	30 e0       	ldi	r19, 0x00	; 0
 4d8:	b9 01       	movw	r22, r18
 4da:	02 c0       	rjmp	.+4      	; 0x4e0 <PIN_MODE+0xbc>
 4dc:	66 0f       	add	r22, r22
 4de:	77 1f       	adc	r23, r23
 4e0:	8a 95       	dec	r24
 4e2:	e2 f7       	brpl	.-8      	; 0x4dc <PIN_MODE+0xb8>
 4e4:	cb 01       	movw	r24, r22
 4e6:	84 2b       	or	r24, r20
 4e8:	84 bb       	out	0x14, r24	; 20
			break;
 4ea:	08 95       	ret
			case 4:
			pin = pin % 40;
 4ec:	9d ec       	ldi	r25, 0xCD	; 205
 4ee:	89 9f       	mul	r24, r25
 4f0:	91 2d       	mov	r25, r1
 4f2:	11 24       	eor	r1, r1
 4f4:	92 95       	swap	r25
 4f6:	96 95       	lsr	r25
 4f8:	97 70       	andi	r25, 0x07	; 7
 4fa:	78 e2       	ldi	r23, 0x28	; 40
 4fc:	97 9f       	mul	r25, r23
 4fe:	80 19       	sub	r24, r0
 500:	11 24       	eor	r1, r1
			SET_BIT(DDRA,pin);
 502:	4a b3       	in	r20, 0x1a	; 26
 504:	21 e0       	ldi	r18, 0x01	; 1
 506:	30 e0       	ldi	r19, 0x00	; 0
 508:	b9 01       	movw	r22, r18
 50a:	02 c0       	rjmp	.+4      	; 0x510 <PIN_MODE+0xec>
 50c:	66 0f       	add	r22, r22
 50e:	77 1f       	adc	r23, r23
 510:	8a 95       	dec	r24
 512:	e2 f7       	brpl	.-8      	; 0x50c <PIN_MODE+0xe8>
 514:	cb 01       	movw	r24, r22
 516:	84 2b       	or	r24, r20
 518:	8a bb       	out	0x1a, r24	; 26
			break;
 51a:	08 95       	ret
		}
		break;
		
		case INPUT:
		switch(port)
 51c:	92 30       	cpi	r25, 0x02	; 2
 51e:	29 f1       	breq	.+74     	; 0x56a <PIN_MODE+0x146>
 520:	18 f4       	brcc	.+6      	; 0x528 <PIN_MODE+0x104>
 522:	91 30       	cpi	r25, 0x01	; 1
 524:	39 f0       	breq	.+14     	; 0x534 <PIN_MODE+0x110>
 526:	08 95       	ret
 528:	93 30       	cpi	r25, 0x03	; 3
 52a:	d1 f1       	breq	.+116    	; 0x5a0 <PIN_MODE+0x17c>
 52c:	94 30       	cpi	r25, 0x04	; 4
 52e:	09 f4       	brne	.+2      	; 0x532 <PIN_MODE+0x10e>
 530:	4f c0       	rjmp	.+158    	; 0x5d0 <PIN_MODE+0x1ac>
 532:	08 95       	ret
		{
			case 1:
			pin = pin % 10;
 534:	9d ec       	ldi	r25, 0xCD	; 205
 536:	89 9f       	mul	r24, r25
 538:	91 2d       	mov	r25, r1
 53a:	11 24       	eor	r1, r1
 53c:	96 95       	lsr	r25
 53e:	96 95       	lsr	r25
 540:	96 95       	lsr	r25
 542:	99 0f       	add	r25, r25
 544:	29 2f       	mov	r18, r25
 546:	22 0f       	add	r18, r18
 548:	22 0f       	add	r18, r18
 54a:	92 0f       	add	r25, r18
 54c:	89 1b       	sub	r24, r25
			CLR_BIT(DDRB,pin);
 54e:	47 b3       	in	r20, 0x17	; 23
 550:	21 e0       	ldi	r18, 0x01	; 1
 552:	30 e0       	ldi	r19, 0x00	; 0
 554:	b9 01       	movw	r22, r18
 556:	02 c0       	rjmp	.+4      	; 0x55c <PIN_MODE+0x138>
 558:	66 0f       	add	r22, r22
 55a:	77 1f       	adc	r23, r23
 55c:	8a 95       	dec	r24
 55e:	e2 f7       	brpl	.-8      	; 0x558 <PIN_MODE+0x134>
 560:	cb 01       	movw	r24, r22
 562:	80 95       	com	r24
 564:	84 23       	and	r24, r20
 566:	87 bb       	out	0x17, r24	; 23
			break;
 568:	08 95       	ret
			case 2:
			pin = pin % 20;
 56a:	9d ec       	ldi	r25, 0xCD	; 205
 56c:	89 9f       	mul	r24, r25
 56e:	91 2d       	mov	r25, r1
 570:	11 24       	eor	r1, r1
 572:	92 95       	swap	r25
 574:	9f 70       	andi	r25, 0x0F	; 15
 576:	99 0f       	add	r25, r25
 578:	99 0f       	add	r25, r25
 57a:	29 2f       	mov	r18, r25
 57c:	22 0f       	add	r18, r18
 57e:	22 0f       	add	r18, r18
 580:	92 0f       	add	r25, r18
 582:	89 1b       	sub	r24, r25
			CLR_BIT(DDRD,pin);
 584:	41 b3       	in	r20, 0x11	; 17
 586:	21 e0       	ldi	r18, 0x01	; 1
 588:	30 e0       	ldi	r19, 0x00	; 0
 58a:	b9 01       	movw	r22, r18
 58c:	02 c0       	rjmp	.+4      	; 0x592 <PIN_MODE+0x16e>
 58e:	66 0f       	add	r22, r22
 590:	77 1f       	adc	r23, r23
 592:	8a 95       	dec	r24
 594:	e2 f7       	brpl	.-8      	; 0x58e <PIN_MODE+0x16a>
 596:	cb 01       	movw	r24, r22
 598:	80 95       	com	r24
 59a:	84 23       	and	r24, r20
 59c:	81 bb       	out	0x11, r24	; 17
			break;
 59e:	08 95       	ret
			case 3:
			pin = pin % 30;
 5a0:	99 e8       	ldi	r25, 0x89	; 137
 5a2:	89 9f       	mul	r24, r25
 5a4:	91 2d       	mov	r25, r1
 5a6:	11 24       	eor	r1, r1
 5a8:	92 95       	swap	r25
 5aa:	9f 70       	andi	r25, 0x0F	; 15
 5ac:	7e e1       	ldi	r23, 0x1E	; 30
 5ae:	97 9f       	mul	r25, r23
 5b0:	80 19       	sub	r24, r0
 5b2:	11 24       	eor	r1, r1
			CLR_BIT(DDRC,pin);
 5b4:	44 b3       	in	r20, 0x14	; 20
 5b6:	21 e0       	ldi	r18, 0x01	; 1
 5b8:	30 e0       	ldi	r19, 0x00	; 0
 5ba:	b9 01       	movw	r22, r18
 5bc:	02 c0       	rjmp	.+4      	; 0x5c2 <PIN_MODE+0x19e>
 5be:	66 0f       	add	r22, r22
 5c0:	77 1f       	adc	r23, r23
 5c2:	8a 95       	dec	r24
 5c4:	e2 f7       	brpl	.-8      	; 0x5be <PIN_MODE+0x19a>
 5c6:	cb 01       	movw	r24, r22
 5c8:	80 95       	com	r24
 5ca:	84 23       	and	r24, r20
 5cc:	84 bb       	out	0x14, r24	; 20
			break;
 5ce:	08 95       	ret
			case 4:
			pin = pin % 40;
 5d0:	9d ec       	ldi	r25, 0xCD	; 205
 5d2:	89 9f       	mul	r24, r25
 5d4:	91 2d       	mov	r25, r1
 5d6:	11 24       	eor	r1, r1
 5d8:	92 95       	swap	r25
 5da:	96 95       	lsr	r25
 5dc:	97 70       	andi	r25, 0x07	; 7
 5de:	78 e2       	ldi	r23, 0x28	; 40
 5e0:	97 9f       	mul	r25, r23
 5e2:	80 19       	sub	r24, r0
 5e4:	11 24       	eor	r1, r1
			CLR_BIT(DDRA,pin);
 5e6:	4a b3       	in	r20, 0x1a	; 26
 5e8:	21 e0       	ldi	r18, 0x01	; 1
 5ea:	30 e0       	ldi	r19, 0x00	; 0
 5ec:	b9 01       	movw	r22, r18
 5ee:	02 c0       	rjmp	.+4      	; 0x5f4 <PIN_MODE+0x1d0>
 5f0:	66 0f       	add	r22, r22
 5f2:	77 1f       	adc	r23, r23
 5f4:	8a 95       	dec	r24
 5f6:	e2 f7       	brpl	.-8      	; 0x5f0 <PIN_MODE+0x1cc>
 5f8:	cb 01       	movw	r24, r22
 5fa:	80 95       	com	r24
 5fc:	84 23       	and	r24, r20
 5fe:	8a bb       	out	0x1a, r24	; 26
 600:	08 95       	ret

00000602 <PIN_WRITE>:
		break;
	}
}
void PIN_WRITE (uint8_t pin,uint8_t status)
{
	uint8_t port = pin / 10;
 602:	9d ec       	ldi	r25, 0xCD	; 205
 604:	89 9f       	mul	r24, r25
 606:	91 2d       	mov	r25, r1
 608:	11 24       	eor	r1, r1
 60a:	96 95       	lsr	r25
 60c:	96 95       	lsr	r25
 60e:	96 95       	lsr	r25
	switch(status)
 610:	66 23       	and	r22, r22
 612:	09 f4       	brne	.+2      	; 0x616 <PIN_WRITE+0x14>
 614:	72 c0       	rjmp	.+228    	; 0x6fa <PIN_WRITE+0xf8>
 616:	61 30       	cpi	r22, 0x01	; 1
 618:	09 f0       	breq	.+2      	; 0x61c <PIN_WRITE+0x1a>
 61a:	e1 c0       	rjmp	.+450    	; 0x7de <PIN_WRITE+0x1dc>
	{
		case HIGH:
		switch(port)
 61c:	92 30       	cpi	r25, 0x02	; 2
 61e:	21 f1       	breq	.+72     	; 0x668 <PIN_WRITE+0x66>
 620:	18 f4       	brcc	.+6      	; 0x628 <PIN_WRITE+0x26>
 622:	91 30       	cpi	r25, 0x01	; 1
 624:	39 f0       	breq	.+14     	; 0x634 <PIN_WRITE+0x32>
 626:	08 95       	ret
 628:	93 30       	cpi	r25, 0x03	; 3
 62a:	c1 f1       	breq	.+112    	; 0x69c <PIN_WRITE+0x9a>
 62c:	94 30       	cpi	r25, 0x04	; 4
 62e:	09 f4       	brne	.+2      	; 0x632 <PIN_WRITE+0x30>
 630:	4c c0       	rjmp	.+152    	; 0x6ca <PIN_WRITE+0xc8>
 632:	08 95       	ret
		{
			case 1:
			pin = pin % 10;
 634:	9d ec       	ldi	r25, 0xCD	; 205
 636:	89 9f       	mul	r24, r25
 638:	91 2d       	mov	r25, r1
 63a:	11 24       	eor	r1, r1
 63c:	96 95       	lsr	r25
 63e:	96 95       	lsr	r25
 640:	96 95       	lsr	r25
 642:	99 0f       	add	r25, r25
 644:	29 2f       	mov	r18, r25
 646:	22 0f       	add	r18, r18
 648:	22 0f       	add	r18, r18
 64a:	92 0f       	add	r25, r18
 64c:	89 1b       	sub	r24, r25
			SET_BIT(PORTB,pin);
 64e:	48 b3       	in	r20, 0x18	; 24
 650:	21 e0       	ldi	r18, 0x01	; 1
 652:	30 e0       	ldi	r19, 0x00	; 0
 654:	b9 01       	movw	r22, r18
 656:	02 c0       	rjmp	.+4      	; 0x65c <PIN_WRITE+0x5a>
 658:	66 0f       	add	r22, r22
 65a:	77 1f       	adc	r23, r23
 65c:	8a 95       	dec	r24
 65e:	e2 f7       	brpl	.-8      	; 0x658 <PIN_WRITE+0x56>
 660:	cb 01       	movw	r24, r22
 662:	84 2b       	or	r24, r20
 664:	88 bb       	out	0x18, r24	; 24
			break;
 666:	08 95       	ret
			case 2:
			pin = pin % 20;
 668:	9d ec       	ldi	r25, 0xCD	; 205
 66a:	89 9f       	mul	r24, r25
 66c:	91 2d       	mov	r25, r1
 66e:	11 24       	eor	r1, r1
 670:	92 95       	swap	r25
 672:	9f 70       	andi	r25, 0x0F	; 15
 674:	99 0f       	add	r25, r25
 676:	99 0f       	add	r25, r25
 678:	29 2f       	mov	r18, r25
 67a:	22 0f       	add	r18, r18
 67c:	22 0f       	add	r18, r18
 67e:	92 0f       	add	r25, r18
 680:	89 1b       	sub	r24, r25
			SET_BIT(PORTD,pin);
 682:	42 b3       	in	r20, 0x12	; 18
 684:	21 e0       	ldi	r18, 0x01	; 1
 686:	30 e0       	ldi	r19, 0x00	; 0
 688:	b9 01       	movw	r22, r18
 68a:	02 c0       	rjmp	.+4      	; 0x690 <PIN_WRITE+0x8e>
 68c:	66 0f       	add	r22, r22
 68e:	77 1f       	adc	r23, r23
 690:	8a 95       	dec	r24
 692:	e2 f7       	brpl	.-8      	; 0x68c <PIN_WRITE+0x8a>
 694:	cb 01       	movw	r24, r22
 696:	84 2b       	or	r24, r20
 698:	82 bb       	out	0x12, r24	; 18
			break;
 69a:	08 95       	ret
			case 3:
			pin = pin % 30;
 69c:	99 e8       	ldi	r25, 0x89	; 137
 69e:	89 9f       	mul	r24, r25
 6a0:	91 2d       	mov	r25, r1
 6a2:	11 24       	eor	r1, r1
 6a4:	92 95       	swap	r25
 6a6:	9f 70       	andi	r25, 0x0F	; 15
 6a8:	7e e1       	ldi	r23, 0x1E	; 30
 6aa:	97 9f       	mul	r25, r23
 6ac:	80 19       	sub	r24, r0
 6ae:	11 24       	eor	r1, r1
			SET_BIT(PORTC,pin);
 6b0:	45 b3       	in	r20, 0x15	; 21
 6b2:	21 e0       	ldi	r18, 0x01	; 1
 6b4:	30 e0       	ldi	r19, 0x00	; 0
 6b6:	b9 01       	movw	r22, r18
 6b8:	02 c0       	rjmp	.+4      	; 0x6be <PIN_WRITE+0xbc>
 6ba:	66 0f       	add	r22, r22
 6bc:	77 1f       	adc	r23, r23
 6be:	8a 95       	dec	r24
 6c0:	e2 f7       	brpl	.-8      	; 0x6ba <PIN_WRITE+0xb8>
 6c2:	cb 01       	movw	r24, r22
 6c4:	84 2b       	or	r24, r20
 6c6:	85 bb       	out	0x15, r24	; 21
			break;
 6c8:	08 95       	ret
			case 4:
			pin = pin % 40;
 6ca:	9d ec       	ldi	r25, 0xCD	; 205
 6cc:	89 9f       	mul	r24, r25
 6ce:	91 2d       	mov	r25, r1
 6d0:	11 24       	eor	r1, r1
 6d2:	92 95       	swap	r25
 6d4:	96 95       	lsr	r25
 6d6:	97 70       	andi	r25, 0x07	; 7
 6d8:	78 e2       	ldi	r23, 0x28	; 40
 6da:	97 9f       	mul	r25, r23
 6dc:	80 19       	sub	r24, r0
 6de:	11 24       	eor	r1, r1
			SET_BIT(PORTA,pin);
 6e0:	4b b3       	in	r20, 0x1b	; 27
 6e2:	21 e0       	ldi	r18, 0x01	; 1
 6e4:	30 e0       	ldi	r19, 0x00	; 0
 6e6:	b9 01       	movw	r22, r18
 6e8:	02 c0       	rjmp	.+4      	; 0x6ee <PIN_WRITE+0xec>
 6ea:	66 0f       	add	r22, r22
 6ec:	77 1f       	adc	r23, r23
 6ee:	8a 95       	dec	r24
 6f0:	e2 f7       	brpl	.-8      	; 0x6ea <PIN_WRITE+0xe8>
 6f2:	cb 01       	movw	r24, r22
 6f4:	84 2b       	or	r24, r20
 6f6:	8b bb       	out	0x1b, r24	; 27
			break;
 6f8:	08 95       	ret
		}
		break;
		
		case LOW:
		switch(port)
 6fa:	92 30       	cpi	r25, 0x02	; 2
 6fc:	29 f1       	breq	.+74     	; 0x748 <PIN_WRITE+0x146>
 6fe:	18 f4       	brcc	.+6      	; 0x706 <PIN_WRITE+0x104>
 700:	91 30       	cpi	r25, 0x01	; 1
 702:	39 f0       	breq	.+14     	; 0x712 <PIN_WRITE+0x110>
 704:	08 95       	ret
 706:	93 30       	cpi	r25, 0x03	; 3
 708:	d1 f1       	breq	.+116    	; 0x77e <PIN_WRITE+0x17c>
 70a:	94 30       	cpi	r25, 0x04	; 4
 70c:	09 f4       	brne	.+2      	; 0x710 <PIN_WRITE+0x10e>
 70e:	4f c0       	rjmp	.+158    	; 0x7ae <PIN_WRITE+0x1ac>
 710:	08 95       	ret
		{
			case 1:
			pin = pin % 10;
 712:	9d ec       	ldi	r25, 0xCD	; 205
 714:	89 9f       	mul	r24, r25
 716:	91 2d       	mov	r25, r1
 718:	11 24       	eor	r1, r1
 71a:	96 95       	lsr	r25
 71c:	96 95       	lsr	r25
 71e:	96 95       	lsr	r25
 720:	99 0f       	add	r25, r25
 722:	29 2f       	mov	r18, r25
 724:	22 0f       	add	r18, r18
 726:	22 0f       	add	r18, r18
 728:	92 0f       	add	r25, r18
 72a:	89 1b       	sub	r24, r25
			CLR_BIT(PORTB,pin);
 72c:	48 b3       	in	r20, 0x18	; 24
 72e:	21 e0       	ldi	r18, 0x01	; 1
 730:	30 e0       	ldi	r19, 0x00	; 0
 732:	b9 01       	movw	r22, r18
 734:	02 c0       	rjmp	.+4      	; 0x73a <PIN_WRITE+0x138>
 736:	66 0f       	add	r22, r22
 738:	77 1f       	adc	r23, r23
 73a:	8a 95       	dec	r24
 73c:	e2 f7       	brpl	.-8      	; 0x736 <PIN_WRITE+0x134>
 73e:	cb 01       	movw	r24, r22
 740:	80 95       	com	r24
 742:	84 23       	and	r24, r20
 744:	88 bb       	out	0x18, r24	; 24
			break;
 746:	08 95       	ret
			case 2:
			pin = pin % 20;
 748:	9d ec       	ldi	r25, 0xCD	; 205
 74a:	89 9f       	mul	r24, r25
 74c:	91 2d       	mov	r25, r1
 74e:	11 24       	eor	r1, r1
 750:	92 95       	swap	r25
 752:	9f 70       	andi	r25, 0x0F	; 15
 754:	99 0f       	add	r25, r25
 756:	99 0f       	add	r25, r25
 758:	29 2f       	mov	r18, r25
 75a:	22 0f       	add	r18, r18
 75c:	22 0f       	add	r18, r18
 75e:	92 0f       	add	r25, r18
 760:	89 1b       	sub	r24, r25
			CLR_BIT(PORTD,pin);
 762:	42 b3       	in	r20, 0x12	; 18
 764:	21 e0       	ldi	r18, 0x01	; 1
 766:	30 e0       	ldi	r19, 0x00	; 0
 768:	b9 01       	movw	r22, r18
 76a:	02 c0       	rjmp	.+4      	; 0x770 <PIN_WRITE+0x16e>
 76c:	66 0f       	add	r22, r22
 76e:	77 1f       	adc	r23, r23
 770:	8a 95       	dec	r24
 772:	e2 f7       	brpl	.-8      	; 0x76c <PIN_WRITE+0x16a>
 774:	cb 01       	movw	r24, r22
 776:	80 95       	com	r24
 778:	84 23       	and	r24, r20
 77a:	82 bb       	out	0x12, r24	; 18
			break;
 77c:	08 95       	ret
			case 3:
			pin = pin % 30;
 77e:	99 e8       	ldi	r25, 0x89	; 137
 780:	89 9f       	mul	r24, r25
 782:	91 2d       	mov	r25, r1
 784:	11 24       	eor	r1, r1
 786:	92 95       	swap	r25
 788:	9f 70       	andi	r25, 0x0F	; 15
 78a:	7e e1       	ldi	r23, 0x1E	; 30
 78c:	97 9f       	mul	r25, r23
 78e:	80 19       	sub	r24, r0
 790:	11 24       	eor	r1, r1
			CLR_BIT(PORTC,pin);
 792:	45 b3       	in	r20, 0x15	; 21
 794:	21 e0       	ldi	r18, 0x01	; 1
 796:	30 e0       	ldi	r19, 0x00	; 0
 798:	b9 01       	movw	r22, r18
 79a:	02 c0       	rjmp	.+4      	; 0x7a0 <PIN_WRITE+0x19e>
 79c:	66 0f       	add	r22, r22
 79e:	77 1f       	adc	r23, r23
 7a0:	8a 95       	dec	r24
 7a2:	e2 f7       	brpl	.-8      	; 0x79c <PIN_WRITE+0x19a>
 7a4:	cb 01       	movw	r24, r22
 7a6:	80 95       	com	r24
 7a8:	84 23       	and	r24, r20
 7aa:	85 bb       	out	0x15, r24	; 21
			break;
 7ac:	08 95       	ret
			case 4:
			pin = pin % 40;
 7ae:	9d ec       	ldi	r25, 0xCD	; 205
 7b0:	89 9f       	mul	r24, r25
 7b2:	91 2d       	mov	r25, r1
 7b4:	11 24       	eor	r1, r1
 7b6:	92 95       	swap	r25
 7b8:	96 95       	lsr	r25
 7ba:	97 70       	andi	r25, 0x07	; 7
 7bc:	78 e2       	ldi	r23, 0x28	; 40
 7be:	97 9f       	mul	r25, r23
 7c0:	80 19       	sub	r24, r0
 7c2:	11 24       	eor	r1, r1
			CLR_BIT(PORTA,pin);
 7c4:	4b b3       	in	r20, 0x1b	; 27
 7c6:	21 e0       	ldi	r18, 0x01	; 1
 7c8:	30 e0       	ldi	r19, 0x00	; 0
 7ca:	b9 01       	movw	r22, r18
 7cc:	02 c0       	rjmp	.+4      	; 0x7d2 <PIN_WRITE+0x1d0>
 7ce:	66 0f       	add	r22, r22
 7d0:	77 1f       	adc	r23, r23
 7d2:	8a 95       	dec	r24
 7d4:	e2 f7       	brpl	.-8      	; 0x7ce <PIN_WRITE+0x1cc>
 7d6:	cb 01       	movw	r24, r22
 7d8:	80 95       	com	r24
 7da:	84 23       	and	r24, r20
 7dc:	8b bb       	out	0x1b, r24	; 27
 7de:	08 95       	ret

000007e0 <PIN_TOGGLE>:
	}
}

void PIN_TOGGLE(uint8_t pin)
{
	uint8_t port = pin / 10;
 7e0:	9d ec       	ldi	r25, 0xCD	; 205
 7e2:	89 9f       	mul	r24, r25
 7e4:	91 2d       	mov	r25, r1
 7e6:	11 24       	eor	r1, r1
 7e8:	96 95       	lsr	r25
 7ea:	96 95       	lsr	r25
 7ec:	96 95       	lsr	r25
	switch(port)
 7ee:	92 30       	cpi	r25, 0x02	; 2
 7f0:	21 f1       	breq	.+72     	; 0x83a <__DATA_REGION_LENGTH__+0x3a>
 7f2:	18 f4       	brcc	.+6      	; 0x7fa <PIN_TOGGLE+0x1a>
 7f4:	91 30       	cpi	r25, 0x01	; 1
 7f6:	39 f0       	breq	.+14     	; 0x806 <__DATA_REGION_LENGTH__+0x6>
 7f8:	08 95       	ret
 7fa:	93 30       	cpi	r25, 0x03	; 3
 7fc:	c1 f1       	breq	.+112    	; 0x86e <__stack+0xf>
 7fe:	94 30       	cpi	r25, 0x04	; 4
 800:	09 f4       	brne	.+2      	; 0x804 <__DATA_REGION_LENGTH__+0x4>
 802:	4c c0       	rjmp	.+152    	; 0x89c <__stack+0x3d>
 804:	08 95       	ret
	{
		case 1:
		pin = pin % 10;
 806:	9d ec       	ldi	r25, 0xCD	; 205
 808:	89 9f       	mul	r24, r25
 80a:	91 2d       	mov	r25, r1
 80c:	11 24       	eor	r1, r1
 80e:	96 95       	lsr	r25
 810:	96 95       	lsr	r25
 812:	96 95       	lsr	r25
 814:	99 0f       	add	r25, r25
 816:	29 2f       	mov	r18, r25
 818:	22 0f       	add	r18, r18
 81a:	22 0f       	add	r18, r18
 81c:	92 0f       	add	r25, r18
 81e:	89 1b       	sub	r24, r25
		TOG_BIT(PORTB,pin);
 820:	48 b3       	in	r20, 0x18	; 24
 822:	21 e0       	ldi	r18, 0x01	; 1
 824:	30 e0       	ldi	r19, 0x00	; 0
 826:	b9 01       	movw	r22, r18
 828:	02 c0       	rjmp	.+4      	; 0x82e <__DATA_REGION_LENGTH__+0x2e>
 82a:	66 0f       	add	r22, r22
 82c:	77 1f       	adc	r23, r23
 82e:	8a 95       	dec	r24
 830:	e2 f7       	brpl	.-8      	; 0x82a <__DATA_REGION_LENGTH__+0x2a>
 832:	cb 01       	movw	r24, r22
 834:	84 27       	eor	r24, r20
 836:	88 bb       	out	0x18, r24	; 24
		break;
 838:	08 95       	ret
		case 2:
		pin = pin % 20;
 83a:	9d ec       	ldi	r25, 0xCD	; 205
 83c:	89 9f       	mul	r24, r25
 83e:	91 2d       	mov	r25, r1
 840:	11 24       	eor	r1, r1
 842:	92 95       	swap	r25
 844:	9f 70       	andi	r25, 0x0F	; 15
 846:	99 0f       	add	r25, r25
 848:	99 0f       	add	r25, r25
 84a:	29 2f       	mov	r18, r25
 84c:	22 0f       	add	r18, r18
 84e:	22 0f       	add	r18, r18
 850:	92 0f       	add	r25, r18
 852:	89 1b       	sub	r24, r25
		TOG_BIT(PORTD,pin);
 854:	42 b3       	in	r20, 0x12	; 18
 856:	21 e0       	ldi	r18, 0x01	; 1
 858:	30 e0       	ldi	r19, 0x00	; 0
 85a:	b9 01       	movw	r22, r18
 85c:	02 c0       	rjmp	.+4      	; 0x862 <__stack+0x3>
 85e:	66 0f       	add	r22, r22
 860:	77 1f       	adc	r23, r23
 862:	8a 95       	dec	r24
 864:	e2 f7       	brpl	.-8      	; 0x85e <__DATA_REGION_LENGTH__+0x5e>
 866:	cb 01       	movw	r24, r22
 868:	84 27       	eor	r24, r20
 86a:	82 bb       	out	0x12, r24	; 18
		break;
 86c:	08 95       	ret
		case 3:
		pin = pin % 30;
 86e:	99 e8       	ldi	r25, 0x89	; 137
 870:	89 9f       	mul	r24, r25
 872:	91 2d       	mov	r25, r1
 874:	11 24       	eor	r1, r1
 876:	92 95       	swap	r25
 878:	9f 70       	andi	r25, 0x0F	; 15
 87a:	7e e1       	ldi	r23, 0x1E	; 30
 87c:	97 9f       	mul	r25, r23
 87e:	80 19       	sub	r24, r0
 880:	11 24       	eor	r1, r1
		TOG_BIT(PORTC,pin);
 882:	45 b3       	in	r20, 0x15	; 21
 884:	21 e0       	ldi	r18, 0x01	; 1
 886:	30 e0       	ldi	r19, 0x00	; 0
 888:	b9 01       	movw	r22, r18
 88a:	02 c0       	rjmp	.+4      	; 0x890 <__stack+0x31>
 88c:	66 0f       	add	r22, r22
 88e:	77 1f       	adc	r23, r23
 890:	8a 95       	dec	r24
 892:	e2 f7       	brpl	.-8      	; 0x88c <__stack+0x2d>
 894:	cb 01       	movw	r24, r22
 896:	84 27       	eor	r24, r20
 898:	85 bb       	out	0x15, r24	; 21
		break;
 89a:	08 95       	ret
		case 4:
		pin = pin % 40;
 89c:	9d ec       	ldi	r25, 0xCD	; 205
 89e:	89 9f       	mul	r24, r25
 8a0:	91 2d       	mov	r25, r1
 8a2:	11 24       	eor	r1, r1
 8a4:	92 95       	swap	r25
 8a6:	96 95       	lsr	r25
 8a8:	97 70       	andi	r25, 0x07	; 7
 8aa:	78 e2       	ldi	r23, 0x28	; 40
 8ac:	97 9f       	mul	r25, r23
 8ae:	80 19       	sub	r24, r0
 8b0:	11 24       	eor	r1, r1
		TOG_BIT(PORTA,pin);
 8b2:	4b b3       	in	r20, 0x1b	; 27
 8b4:	21 e0       	ldi	r18, 0x01	; 1
 8b6:	30 e0       	ldi	r19, 0x00	; 0
 8b8:	b9 01       	movw	r22, r18
 8ba:	02 c0       	rjmp	.+4      	; 0x8c0 <__stack+0x61>
 8bc:	66 0f       	add	r22, r22
 8be:	77 1f       	adc	r23, r23
 8c0:	8a 95       	dec	r24
 8c2:	e2 f7       	brpl	.-8      	; 0x8bc <__stack+0x5d>
 8c4:	cb 01       	movw	r24, r22
 8c6:	84 27       	eor	r24, r20
 8c8:	8b bb       	out	0x1b, r24	; 27
 8ca:	08 95       	ret

000008cc <EXT_INT_0_INIT_RISING_EDGE>:
#include "../../Utilities/BIT_MATH.h"
#include "../REGISTERS.h"

void EXT_INT_0_INIT_RISING_EDGE (void)
{
	SET_BIT(MCUCR,0);        //Interrupt on Rising edge
 8cc:	85 b7       	in	r24, 0x35	; 53
 8ce:	81 60       	ori	r24, 0x01	; 1
 8d0:	85 bf       	out	0x35, r24	; 53
	SET_BIT(MCUCR,1);
 8d2:	85 b7       	in	r24, 0x35	; 53
 8d4:	82 60       	ori	r24, 0x02	; 2
 8d6:	85 bf       	out	0x35, r24	; 53
 8d8:	08 95       	ret

000008da <TIMER_0_INIT>:
}

void TIMER_0_INIT			(void)		//	timer 0 mode
{
	#if  TIMER0_MODE == NORMAL
	CLR_BIT(TCCR0,3);
 8da:	83 b7       	in	r24, 0x33	; 51
 8dc:	87 7f       	andi	r24, 0xF7	; 247
 8de:	83 bf       	out	0x33, r24	; 51
	CLR_BIT(TCCR0,6);
 8e0:	83 b7       	in	r24, 0x33	; 51
 8e2:	8f 7b       	andi	r24, 0xBF	; 191
 8e4:	83 bf       	out	0x33, r24	; 51
 8e6:	08 95       	ret

000008e8 <TIMER_0_START>:
	#elif TIMER0_SOURCE == _256
	CLR_BIT(TCCR0,0);
	CLR_BIT(TCCR0,1);
	SET_BIT(TCCR0,2);
	#elif TIMER0_SOURCE == _1024
	SET_BIT(TCCR0,0);
 8e8:	83 b7       	in	r24, 0x33	; 51
 8ea:	81 60       	ori	r24, 0x01	; 1
 8ec:	83 bf       	out	0x33, r24	; 51
	CLR_BIT(TCCR0,1);
 8ee:	83 b7       	in	r24, 0x33	; 51
 8f0:	8d 7f       	andi	r24, 0xFD	; 253
 8f2:	83 bf       	out	0x33, r24	; 51
	SET_BIT(TCCR0,2);
 8f4:	83 b7       	in	r24, 0x33	; 51
 8f6:	84 60       	ori	r24, 0x04	; 4
 8f8:	83 bf       	out	0x33, r24	; 51
 8fa:	08 95       	ret

000008fc <TIMER_0_STOP>:
	#endif	
}

void TIMER_0_STOP		(void)
{
	CLR_BIT(TCCR0,0);
 8fc:	83 b7       	in	r24, 0x33	; 51
 8fe:	8e 7f       	andi	r24, 0xFE	; 254
 900:	83 bf       	out	0x33, r24	; 51
	CLR_BIT(TCCR0,1);
 902:	83 b7       	in	r24, 0x33	; 51
 904:	8d 7f       	andi	r24, 0xFD	; 253
 906:	83 bf       	out	0x33, r24	; 51
	CLR_BIT(TCCR0,2);
 908:	83 b7       	in	r24, 0x33	; 51
 90a:	8b 7f       	andi	r24, 0xFB	; 251
 90c:	83 bf       	out	0x33, r24	; 51
 90e:	08 95       	ret

00000910 <TIMER_0_5s_DELAY>:
	
	
void TIMER_0_5s_DELAY		(void)
{
	uint8_t number_of_overflows=0;
	TCNT0=TIMER0_INITAL_VALUE;
 910:	8c e0       	ldi	r24, 0x0C	; 12
 912:	82 bf       	out	0x32, r24	; 50
	TIMER_0_START();
 914:	0e 94 74 04 	call	0x8e8	; 0x8e8 <TIMER_0_START>
	SET_BIT(TIFR,0);	//CLEAR TIMER OVF FLAG	
 918:	88 b7       	in	r24, 0x38	; 56
 91a:	81 60       	ori	r24, 0x01	; 1
 91c:	88 bf       	out	0x38, r24	; 56
	//5 seconds>> 4*5=20 OVF
	
	
void TIMER_0_5s_DELAY		(void)
{
	uint8_t number_of_overflows=0;
 91e:	90 e0       	ldi	r25, 0x00	; 0
	TCNT0=TIMER0_INITAL_VALUE;
	TIMER_0_START();
	SET_BIT(TIFR,0);	//CLEAR TIMER OVF FLAG	
	
	while(number_of_overflows<=TIMER0_NUM_OVFS_5s)
 920:	07 c0       	rjmp	.+14     	; 0x930 <TIMER_0_5s_DELAY+0x20>
	{
		while(!GET_BIT(TIFR,0));//check for OVF Flag
 922:	08 b6       	in	r0, 0x38	; 56
 924:	00 fe       	sbrs	r0, 0
 926:	fd cf       	rjmp	.-6      	; 0x922 <TIMER_0_5s_DELAY+0x12>
	
		SET_BIT(TIFR,0);			//Clear flag
 928:	88 b7       	in	r24, 0x38	; 56
 92a:	81 60       	ori	r24, 0x01	; 1
 92c:	88 bf       	out	0x38, r24	; 56
		number_of_overflows++;
 92e:	9f 5f       	subi	r25, 0xFF	; 255
	uint8_t number_of_overflows=0;
	TCNT0=TIMER0_INITAL_VALUE;
	TIMER_0_START();
	SET_BIT(TIFR,0);	//CLEAR TIMER OVF FLAG	
	
	while(number_of_overflows<=TIMER0_NUM_OVFS_5s)
 930:	95 31       	cpi	r25, 0x15	; 21
 932:	b8 f3       	brcs	.-18     	; 0x922 <TIMER_0_5s_DELAY+0x12>
		while(!GET_BIT(TIFR,0));//check for OVF Flag
	
		SET_BIT(TIFR,0);			//Clear flag
		number_of_overflows++;
	}
	TIMER_0_STOP();
 934:	0e 94 7e 04 	call	0x8fc	; 0x8fc <TIMER_0_STOP>
 938:	08 95       	ret

0000093a <TIMER_0_1s_DELAY>:


void TIMER_0_1s_DELAY		(void)
{
	uint8_t number_of_overflows=0;
	TCNT0=TIMER0_INITAL_VALUE;
 93a:	8c e0       	ldi	r24, 0x0C	; 12
 93c:	82 bf       	out	0x32, r24	; 50
	TIMER_0_START();
 93e:	0e 94 74 04 	call	0x8e8	; 0x8e8 <TIMER_0_START>
	SET_BIT(TIFR,0);
 942:	88 b7       	in	r24, 0x38	; 56
 944:	81 60       	ori	r24, 0x01	; 1
 946:	88 bf       	out	0x38, r24	; 56
}


void TIMER_0_1s_DELAY		(void)
{
	uint8_t number_of_overflows=0;
 948:	90 e0       	ldi	r25, 0x00	; 0
	TCNT0=TIMER0_INITAL_VALUE;
	TIMER_0_START();
	SET_BIT(TIFR,0);
	
	while(number_of_overflows<=TIMER0_NUM_OVFS_1s)
 94a:	07 c0       	rjmp	.+14     	; 0x95a <TIMER_0_1s_DELAY+0x20>
	{
	
		while(!GET_BIT(TIFR,0));//check for OVF Flag
 94c:	08 b6       	in	r0, 0x38	; 56
 94e:	00 fe       	sbrs	r0, 0
 950:	fd cf       	rjmp	.-6      	; 0x94c <TIMER_0_1s_DELAY+0x12>
		
		SET_BIT(TIFR,0);			//Clear flag
 952:	88 b7       	in	r24, 0x38	; 56
 954:	81 60       	ori	r24, 0x01	; 1
 956:	88 bf       	out	0x38, r24	; 56
		number_of_overflows++;
 958:	9f 5f       	subi	r25, 0xFF	; 255
	uint8_t number_of_overflows=0;
	TCNT0=TIMER0_INITAL_VALUE;
	TIMER_0_START();
	SET_BIT(TIFR,0);
	
	while(number_of_overflows<=TIMER0_NUM_OVFS_1s)
 95a:	95 30       	cpi	r25, 0x05	; 5
 95c:	b8 f3       	brcs	.-18     	; 0x94c <TIMER_0_1s_DELAY+0x12>
		
		SET_BIT(TIFR,0);			//Clear flag
		number_of_overflows++;
	}
	
	TIMER_0_STOP();
 95e:	0e 94 7e 04 	call	0x8fc	; 0x8fc <TIMER_0_STOP>
 962:	08 95       	ret

00000964 <TIMER_2_INIT>:
//TIMER 2

void TIMER_2_INIT			(void)
{
	//Normal Mode
	CLR_BIT(TCCR2,6);
 964:	85 b5       	in	r24, 0x25	; 37
 966:	8f 7b       	andi	r24, 0xBF	; 191
 968:	85 bd       	out	0x25, r24	; 37
	CLR_BIT(TCCR2,3);
 96a:	85 b5       	in	r24, 0x25	; 37
 96c:	87 7f       	andi	r24, 0xF7	; 247
 96e:	85 bd       	out	0x25, r24	; 37
 970:	08 95       	ret

00000972 <TIMER_2_START>:
}
void TIMER_2_START			(void)
{
	//PRESCALER 1024
	SET_BIT(TCCR2,0);
 972:	85 b5       	in	r24, 0x25	; 37
 974:	81 60       	ori	r24, 0x01	; 1
 976:	85 bd       	out	0x25, r24	; 37
	SET_BIT(TCCR2,1);
 978:	85 b5       	in	r24, 0x25	; 37
 97a:	82 60       	ori	r24, 0x02	; 2
 97c:	85 bd       	out	0x25, r24	; 37
	SET_BIT(TCCR2,2);
 97e:	85 b5       	in	r24, 0x25	; 37
 980:	84 60       	ori	r24, 0x04	; 4
 982:	85 bd       	out	0x25, r24	; 37
 984:	08 95       	ret

00000986 <TIMER_2_STOP>:
}
void TIMER_2_STOP			(void)
{
	CLR_BIT(TCCR2,0);
 986:	85 b5       	in	r24, 0x25	; 37
 988:	8e 7f       	andi	r24, 0xFE	; 254
 98a:	85 bd       	out	0x25, r24	; 37
	CLR_BIT(TCCR2,1);
 98c:	85 b5       	in	r24, 0x25	; 37
 98e:	8d 7f       	andi	r24, 0xFD	; 253
 990:	85 bd       	out	0x25, r24	; 37
	CLR_BIT(TCCR2,2);
 992:	85 b5       	in	r24, 0x25	; 37
 994:	8b 7f       	andi	r24, 0xFB	; 251
 996:	85 bd       	out	0x25, r24	; 37
 998:	08 95       	ret

0000099a <TIMER_2_5s_DELAY>:


void TIMER_2_5s_DELAY		(void)
{
	uint8_t number_of_overflows=0;
	TCNT2=TIMER0_INITAL_VALUE;
 99a:	8c e0       	ldi	r24, 0x0C	; 12
 99c:	84 bd       	out	0x24, r24	; 36
	TIMER_2_START();
 99e:	0e 94 b9 04 	call	0x972	; 0x972 <TIMER_2_START>
	SET_BIT(TIFR,6);	//CLEAR TIMER OVF FLAG
 9a2:	88 b7       	in	r24, 0x38	; 56
 9a4:	80 64       	ori	r24, 0x40	; 64
 9a6:	88 bf       	out	0x38, r24	; 56
}


void TIMER_2_5s_DELAY		(void)
{
	uint8_t number_of_overflows=0;
 9a8:	90 e0       	ldi	r25, 0x00	; 0
	TCNT2=TIMER0_INITAL_VALUE;
	TIMER_2_START();
	SET_BIT(TIFR,6);	//CLEAR TIMER OVF FLAG
	
	while(number_of_overflows<=TIMER0_NUM_OVFS_5s)
 9aa:	07 c0       	rjmp	.+14     	; 0x9ba <TIMER_2_5s_DELAY+0x20>
	{
		while(!GET_BIT(TIFR,6));//check for OVF Flag
 9ac:	08 b6       	in	r0, 0x38	; 56
 9ae:	06 fe       	sbrs	r0, 6
 9b0:	fd cf       	rjmp	.-6      	; 0x9ac <TIMER_2_5s_DELAY+0x12>
		SET_BIT(TIFR,6);			//Clear flag
 9b2:	88 b7       	in	r24, 0x38	; 56
 9b4:	80 64       	ori	r24, 0x40	; 64
 9b6:	88 bf       	out	0x38, r24	; 56
		number_of_overflows++;
 9b8:	9f 5f       	subi	r25, 0xFF	; 255
	uint8_t number_of_overflows=0;
	TCNT2=TIMER0_INITAL_VALUE;
	TIMER_2_START();
	SET_BIT(TIFR,6);	//CLEAR TIMER OVF FLAG
	
	while(number_of_overflows<=TIMER0_NUM_OVFS_5s)
 9ba:	95 31       	cpi	r25, 0x15	; 21
 9bc:	b8 f3       	brcs	.-18     	; 0x9ac <TIMER_2_5s_DELAY+0x12>
	{
		while(!GET_BIT(TIFR,6));//check for OVF Flag
		SET_BIT(TIFR,6);			//Clear flag
		number_of_overflows++;
	}
	TIMER_2_STOP();
 9be:	0e 94 c3 04 	call	0x986	; 0x986 <TIMER_2_STOP>
 9c2:	08 95       	ret

000009c4 <TIMER_2_1s_DELAY>:


void TIMER_2_1s_DELAY		(void)
{
	uint8_t number_of_overflows=0;
	TCNT2=TIMER0_INITAL_VALUE;
 9c4:	8c e0       	ldi	r24, 0x0C	; 12
 9c6:	84 bd       	out	0x24, r24	; 36
	TIMER_2_START();
 9c8:	0e 94 b9 04 	call	0x972	; 0x972 <TIMER_2_START>
	SET_BIT(TIFR,6);
 9cc:	88 b7       	in	r24, 0x38	; 56
 9ce:	80 64       	ori	r24, 0x40	; 64
 9d0:	88 bf       	out	0x38, r24	; 56
}


void TIMER_2_1s_DELAY		(void)
{
	uint8_t number_of_overflows=0;
 9d2:	90 e0       	ldi	r25, 0x00	; 0
	TCNT2=TIMER0_INITAL_VALUE;
	TIMER_2_START();
	SET_BIT(TIFR,6);
	
	while(number_of_overflows<=TIMER0_NUM_OVFS_1s)
 9d4:	07 c0       	rjmp	.+14     	; 0x9e4 <TIMER_2_1s_DELAY+0x20>
	{
		while(!GET_BIT(TIFR,6));//check for OVF Flag
 9d6:	08 b6       	in	r0, 0x38	; 56
 9d8:	06 fe       	sbrs	r0, 6
 9da:	fd cf       	rjmp	.-6      	; 0x9d6 <TIMER_2_1s_DELAY+0x12>
		SET_BIT(TIFR,6);			//Clear flag
 9dc:	88 b7       	in	r24, 0x38	; 56
 9de:	80 64       	ori	r24, 0x40	; 64
 9e0:	88 bf       	out	0x38, r24	; 56
		number_of_overflows++;
 9e2:	9f 5f       	subi	r25, 0xFF	; 255
	uint8_t number_of_overflows=0;
	TCNT2=TIMER0_INITAL_VALUE;
	TIMER_2_START();
	SET_BIT(TIFR,6);
	
	while(number_of_overflows<=TIMER0_NUM_OVFS_1s)
 9e4:	95 30       	cpi	r25, 0x05	; 5
 9e6:	b8 f3       	brcs	.-18     	; 0x9d6 <TIMER_2_1s_DELAY+0x12>
		while(!GET_BIT(TIFR,6));//check for OVF Flag
		SET_BIT(TIFR,6);			//Clear flag
		number_of_overflows++;
	}
	
	TIMER_2_STOP();
 9e8:	0e 94 c3 04 	call	0x986	; 0x986 <TIMER_2_STOP>
 9ec:	08 95       	ret

000009ee <_exit>:
 9ee:	f8 94       	cli

000009f0 <__stop_program>:
 9f0:	ff cf       	rjmp	.-2      	; 0x9f0 <__stop_program>
